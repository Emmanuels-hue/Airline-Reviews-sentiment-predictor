# -*- coding: utf-8 -*-
"""app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kn00ESw9Ur2dwDXp8EONqVUlRyKdXEdC
"""

import streamlit as st
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.svm import LinearSVC
from sklearn.naive_bayes import MultinomialNB
from xgboost import XGBClassifier
from sklearn.metrics import accuracy_score, confusion_matrix
from sklearn.preprocessing import LabelEncoder
import os

st.set_page_config(page_title="Airline Sentiment Analysis", layout="wide")

@st.cache_data
def load_data(filepath='new_reviews.csv'):
    if not os.path.exists(filepath):
        st.error(f"Error: '{filepath}' not found.")
        st.info(f"Please make sure '{filepath}' is in the same directory.")
        return None

    df = pd.read_csv(filepath)
    df.dropna(subset=['review', 'sentiment'], inplace=True)
    return df

@st.cache_data
def train_and_compare_models(df):

    X = df['review']
    y = df['sentiment']

    le = LabelEncoder()
    y_encoded = le.fit_transform(y)

    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42, stratify=y)
    y_train_encoded, y_test_encoded = train_test_split(y_encoded, test_size=0.2, random_state=42, stratify=y_encoded)

    tfidf_vectorizer = TfidfVectorizer(max_features=7000)
    X_train_tfidf = tfidf_vectorizer.fit_transform(X_train)
    X_test_tfidf = tfidf_vectorizer.transform(X_test)

    models = {
        "Naive Bayes": MultinomialNB(),
        "Linear SVM": LinearSVC(random_state=42, dual=False, max_iter=1000),
        "XGBoost": XGBClassifier(random_state=42, use_label_encoder=False,
                                 eval_metric='logloss')
    }

    results = {}
    trained_models = {}

    for name, model in models.items():
        if name == "XGBoost":
            model.fit(X_train_tfidf, y_train_encoded)
            y_pred_encoded = model.predict(X_test_tfidf)
            y_pred = le.inverse_transform(y_pred_encoded)
            y_true = y_test
        else:
            model.fit(X_train_tfidf, y_train)
            y_pred = model.predict(X_test_tfidf)
            y_true = y_test

        accuracy = accuracy_score(y_true, y_pred)
        results[name] = {"accuracy": accuracy, "y_pred": y_pred}
        trained_models[name] = model


    fig_acc, ax_acc = plt.subplots(figsize=(10, 6))
    accuracies = {name: data["accuracy"] for name, data in results.items()}
    sns.barplot(x=list(accuracies.keys()), y=list(accuracies.values()), palette="viridis", ax=ax_acc)
    ax_acc.set_title("Model Accuracy Comparison", fontsize=16)
    ax_acc.set_ylabel("Accuracy")
    ax_acc.set_ylim(0.7, 1.0)
    for i, acc in enumerate(accuracies.values()):
        ax_acc.text(i, acc + 0.005, f'{acc:.4f}', ha='center')


    fig_cm, axes_cm = plt.subplots(1, 3, figsize=(24, 7))
    fig_cm.suptitle("Confusion Matrices", fontsize=16)
    for i, (name, data) in enumerate(results.items()):
        cm = confusion_matrix(y_test, data["y_pred"], labels=le.classes_)
        sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', ax=axes_cm[i],
                    xticklabels=le.classes_, yticklabels=le.classes_)
        axes_cm[i].set_title(name)
        axes_cm[i].set_xlabel("Predicted Label")
        axes_cm[i].set_ylabel("True Label")
    plt.tight_layout(rect=[0, 0.03, 1, 0.95])

    return trained_models, tfidf_vectorizer, le, fig_acc, fig_cm

def predict_new_review(review_text, model, vectorizer, label_encoder):
    cleaned_review = [str(review_text).lower()]